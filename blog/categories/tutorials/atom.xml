<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tutorials | Scott Smith]]></title>
  <link href="http://scottksmith.com/blog/categories/tutorials/atom.xml" rel="self"/>
  <link href="http://scottksmith.com/"/>
  <updated>2017-04-01T19:09:20-07:00</updated>
  <id>http://scottksmith.com/</id>
  <author>
    <name><![CDATA[Scott Smith]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Twitatron: Building a production web app with Node - User Accounts]]></title>
    <link href="http://scottksmith.com/blog/2015/05/26/twitatron-building-a-production-web-app-with-node-user-accounts/"/>
    <updated>2015-05-26T07:55:00-07:00</updated>
    <id>http://scottksmith.com/blog/2015/05/26/twitatron-building-a-production-web-app-with-node-user-accounts</id>
    <content type="html"><![CDATA[<p>Welcome to part 3 of the Twitaron series</p>

<ol>
<li><a href="/blog/2014/10/05/twitatron-building-a-production-web-app-with-node/">Getting started</a></li>
<li><a href="/blog/2015/03/23/twitatron-building-a-production-web-app-with-node-views-and-controllers/">Views &amp; Controllers</a></li>
<li><a href="/blog/2015/05/26/twitatron-building-a-production-web-app-with-node-user-accounts/">User Accounts</a></li>
<li>Under development...</li>
</ol>


<p>In our <a href="/blog/2015/03/23/twitatron-building-a-production-web-app-with-node-views-and-controllers/">previous article</a> we leared how to add views, layouts, partials, controllers, and more.</p>

<p>In this installment of the Twitatron series, we will be diving into how to implement user accounts. By the end of this article you will have learned how to connect to MongoDB, used Mongoose for object modeling, implemented Passport for user authentication, allow users to login with their Twitter account, and have full support for user accounts.</p>

<h3>Secrets</h3>

<p>Before we go further into setting up support for logging in with Twitter, we need to add a way to easily develop locally and run in production. There are going to be settings that are different locally versus production and we don't want these production values in our source code. There are many ways to handle this, but one way I like is to use a secrets module.</p>

<p>If you don't already have a <code>config</code> directory in the root of your application, create one now. Inside this directory, create a new filed named <code>secrets.js</code>. Update this file to contain the following. We will be using many of these items in this and future tutorials.</p>

<p>```javascript
module.exports = {
  db: process.env.MONGODB || 'mongodb://localhost:27017/twitatron',</p>

<p>  cryptos: {</p>

<pre><code>algorithm: 'aes256',
key: process.env.CRYPTO_KEY || 'Your crypto key goes here' 
</code></pre>

<p>  },</p>

<p>  sessionSecret: process.env.SESSION_SECRET || 'Your session secret goes here',</p>

<p>  twitter: {</p>

<pre><code>consumerKey: process.env.TWITTER_KEY || 'Your Twitter consumer key',
consumerSecret: process.env.TWITTER_SECRET  || 'Your Twitter consumer secret',
callbackURL: process.env.TWITTER_CALLBACK || 'http://localhost:3000/auth/twitter/callback',
passReqToCallback: true
</code></pre>

<p>  }
};
```</p>

<p>When your application runs in production, you can setup all the necessary environment variables so they are used within your application. When you run locally, it will use the values specified within this module.</p>

<p>The last thing we need to do is use this module within our application. Update the code in <code>server.js</code> from our previous article to look like the following.</p>

<p><code>javascript
// Load required packages
var path = require('path');
var express = require('express');
var compression = require('compression');
var secrets = require('./config/secrets');
</code></p>

<h3>Connecting to MongoDB</h3>

<p>If you don't already have MondgoDB installed and running, you will want to go their <a href="https://www.mongodb.org/">official site</a> and follow their installation instructions.</p>

<p>There are three things we need to do to connect to MongoDB.</p>

<ol>
<li>Install the Mongoose package</li>
<li>Load the Mongoose package</li>
<li>Connect to it using our connection string</li>
</ol>


<p>Install the package manually using the following command:</p>

<p><code>tcsh
npm install mongoose --save
</code></p>

<p>Update the code in <code>server.js</code> from our previous article to look like the following.</p>

<p><code>javascript
// Load required packages
var path = require('path');
var express = require('express');
var compression = require('compression');
var secrets = require('./config/secrets');
var mongoose = require('mongoose');
</code></p>

<p>Connect to MongoDB</p>

<p>```javascript
// Load required packages
var path = require('path');
var express = require('express');
var compression = require('compression');
var secrets = require('./config/secrets');
var mongoose = require('mongoose');</p>

<p>// Connect to the twitatron MongoDB
mongoose.connect(secrets.db);
```</p>

<p>If all goes well, your application should start up just fine. You will notice we are already using our secrets module for the MongoDB connection string.</p>

<h3>User Model</h3>

<p>We now need a model to store our user. Inside the <code>models</code> directory, create a file named <code>user.js</code> and add the following code to it. If you don't have a <code>models</code> directory, go ahead and create one in the root of your application.</p>

<p>```javascript
// Load required packages
var mongoose = require('mongoose');
var crypto = require('crypto');
var secrets = require('../config/secrets');</p>

<p>// Define our user schema
var UserSchema = new mongoose.Schema({
  twitterId: { type: String, unique: true, required: true },
  username: { type: String, unique: true, lowercase: true, required: true },
  email: { type: String, lowercase: true },
  name: { type: String, default: '' },
  created: { type: Date, default: new Date() },
  accessToken: { type: String, required: true },
  tokenSecret: { type: String, required: true }
});</p>

<p>UserSchema.methods.encrypt = function(text) {
  var algorithm = secrets.cryptos.algorithm;
  var key = secrets.cryptos.key;</p>

<p>  var cipher = crypto.createCipher(algorithm, key);<br/>
  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
};</p>

<p>UserSchema.methods.decrypt = function(text) {
  var algorithm = secrets.cryptos.algorithm;
  var key = secrets.cryptos.key;</p>

<p>  var decipher = crypto.createDecipher(algorithm, key);
  return decipher.update(text, 'hex', 'utf8') + decipher.final('utf8');
};</p>

<p>// Export the Mongoose model
module.exports = mongoose.model('User', UserSchema);
```</p>

<p>So what is going on here?</p>

<ol>
<li>We loaded the Mongoose package</li>
<li>Created a Mongoose schema which maps to a MongoDB collection and defines the shape of the documents within that collection.</li>
<li>We defined our schema to contain twitterId, username, email, name, created date, access token, and token secret.</li>
<li>We exported the Mongoose user model for use within our application.</li>
<li>We created two methods on our schema that we will use to encrypt and decrypt the access token and token secret.</li>
</ol>


<h3>Auth Controller</h3>

<p><code>tcsh
npm install passport --save
npm install passport-twitter --save
</code></p>

<p>This will install the standard passport package along with passport-twitter. Passport-twitter will provide our application with Twitter authentication strategies. It will allow us to easily add Twitter login to our app.</p>

<p>In the <code>controllers</code> directory, add a file named <code>auth.js</code> with the following contents.</p>

<p>```javascript
// Load required packages
var passport = require('passport');
var TwitterStrategy = require('passport-twitter').Strategy;
var User = require('../models/user');
var secrets = require('../config/secrets');</p>

<p>passport.serializeUser(function(user, done) {
  done(null, user);
});</p>

<p>passport.deserializeUser(function(user, done) {
  done(null, user);
});</p>

<p>passport.use(new TwitterStrategy(secrets.twitter, function(req, accessToken, tokenSecret, profile, done) {
  User.findOne({ twitterId: profile.id }, function(err, existingUser) {</p>

<pre><code>if (existingUser) return done(null, existingUser);

var user = new User();

user.twitterId = profile.id;
user.username = profile.id;
user.email = '';
user.name = profile.displayName;
user.created = new Date();
user.accessToken = user.encrypt(accessToken);
user.tokenSecret = user.encrypt(tokenSecret);

user.save(function(err) {
  done(err, user);
});
</code></pre>

<p>  });
}));</p>

<p>exports.twitter = passport.authenticate('twitter');
exports.twitterCallback = passport.authenticate('twitter', { failureRedirect: '/' });
```</p>

<p>What we are doing here is setting up passport to use the Twitter authentication strategy provided by the passport-twitter package. For our TwitterStrategy, we are defining a callback that will attempt to look up the user using the Twitter profile id and if found not found, create a new user. If all works well, it will return an existing user or create a new user.</p>

<p>The final piece of this is exporting the <code>auth</code> and <code>authCallback</code> functions which will be used within our application as route endpoints responsible for creating and logging users in via Twitter. Open up <code>server.js</code> and set it to the following code.</p>

<p>Also, because Passport Twitter strategy requires sessions, be sure to install the <code>express-session</code> package.</p>

<p><code>tcsh
npm install express-session --save
</code></p>

<p>```javascript
// Load required packages
var path = require('path');
var express = require('express');
var compression = require('compression');
var secrets = require('./config/secrets');
var mongoose = require('mongoose');
var passport = require('passport');
var session = require('express-session');</p>

<p>// Connect to the twitatron MongoDB
mongoose.connect(secrets.db);</p>

<p>// Load controllers
var homeController = require('./controllers/home');
var authController = require('./controllers/auth');</p>

<p>// Create our Express application
var app = express();</p>

<p>// Tell Express to use sessions
app.use(session({
  secret: secrets.sessionSecret,
  resave: false,
  saveUninitialized: false,
}));</p>

<p>// Use the passport package in our application
app.use(passport.initialize());
app.use(passport.session());</p>

<p>// Add content compression middleware
app.use(compression());</p>

<p>// Add static middleware
var oneDay = 86400000;
app.use(express.static(path.join(__dirname, 'public'), { maxAge: oneDay }));</p>

<p>// Add jade view engine
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');</p>

<p>// Create our Express router
var router = express.Router();</p>

<p>// Landing page route
router.get('/', homeController.index);</p>

<p>// Auth routes
router.get('/auth/twitter', authController.twitter);
router.get('/auth/twitter/callback', authController.twitterCallback, function(req, res) {
  res.redirect(req.session.returnTo || '/');});</p>

<p>// Register all our routes
app.use(router);</p>

<p>// Start the server
app.listen(3000);
```</p>

<p>What we did here was to include the passport, express-session, and authController modules. After that we setup our Express application to use passport and passport session as middleware. Finally, we create two new endpoints responsible for logging users in via Twitter.</p>

<p>In order to test this, you will need to head to Twitter and register an application. You can do that here: <a href="https://apps.twitter.com/">https://apps.twitter.com/</a>. Once you have an application, update the consumer key and secret inside <code>secrets.js</code>.</p>

<p>You can now test things out by making a request to <a href="http://localhost:3000/auth/twitter">http://localhost:3000/auth/twitter</a></p>

<h3>Clean up our views</h3>

<p>Before we update our views to support logging in and out, we need to clean up our views and some of the code behind it first.</p>

<p>Open up <code>homeController.js</code> and delete this line from the index action: <code>res.locals.ip = req.ip;</code>.</p>

<p>Open up <code>home.jade</code> and delete this line from the view: <code>h2 You are visiting from #{ip}</code>.</p>

<h3>Allow users to login and logout</h3>

<p>To know whether or not a user is currently logged in, we need to add a little code to our Express application. One of the nice things Passport provides is that it automatically adds a user object to the Express request object when someone is logged in. We can take advantage of this by passing it to our views. Open up <code>server.js</code> and update the code as follows right after we use passport.session.</p>

<p><code>javascript
// Setup objects needed by views
app.use(function(req, res, next) {
  res.locals.user = req.user;
  next();
});
</code></p>

<p>What we are doing is adding the user object to the locals object in order to make it available in our views.</p>

<p>Next, we will want to update <code>navigation.jade</code> to show login or logout depending on the user's state.</p>

<p>```jade
header
  div</p>

<pre><code>a(href='/') Twitatron
if !user
  a(href="/auth/twitter") Login with Twitter
else
  a(href="/auth/logout") Logout
</code></pre>

<p>```</p>

<p>The last thing we need to implement is a controller action for the route <code>/auth/logout</code>. Open up <code>authController.js</code> and add the following to the very end.</p>

<p><code>javascript
exports.logout = function(req, res) {
  req.logout();
  req.session.destroy();
  res.redirect('/');
};
</code></p>

<p>Now, just define your route within <code>server.js</code> as follows.</p>

<p><code>javascript
// Auth routes
router.get('/auth/twitter', authController.twitter);
router.get('/auth/twitter/callback', authController.twitterCallback, function(req, res) {
  res.redirect(req.session.returnTo || '/');});
router.get('/auth/logout', authController.logout);
</code></p>

<p>Go ahead and try things out. You should be able to click <code>Login with Twitter</code>, get redirected to Twitter, authorize access to your Twitter account, and have a User created or get logged in as an existing user.</p>

<h3>Wrap up</h3>

<p>We covered a lot of areas in this tutorial. First, we added a configuration module which allows easy configuration between development and production. Second, we learned about Mongoose and connected to MongoDB. Third, we created a Mongoose User model and created helper methods that allow us to encrypt and decrypt sensitive information such as access tokens and token secrets. Finally, we added the ability to log in with Twitter, have a user account created, and then log out.</p>

<p>If you found this article or others useful be sure to <a href="http://scottksmith.com/atom.xml">subscribe to my RSS feed</a> or <a href="https://twitter.com/scottksmith95">follow me on Twitter</a>. Also, if there are certain topics you would like me to write on, feel free to leave comments and let me know.</p>

<p>Source code for this part can be found <a href="https://github.com/scottksmith95/twitatron/tree/master/03">here on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algolia Real Time Search With ASP.NET MVC &amp; Windows Phone 8.1]]></title>
    <link href="http://scottksmith.com/blog/2015/04/04/algolia-real-time-search-with-asp-dot-net-mvc-and-windows-phone-8-dot-1/"/>
    <updated>2015-04-04T20:11:00-07:00</updated>
    <id>http://scottksmith.com/blog/2015/04/04/algolia-real-time-search-with-asp-dot-net-mvc-and-windows-phone-8-dot-1</id>
    <content type="html"><![CDATA[<p>In this article, we are going to explore how to easily add Algolia search to a Windows Phone 8.1 application with an ASP.NET MVC backend. To do this, we will take advantage of Algolia's <a href="https://github.com/algolia/algoliasearch-client-csharp">C# client</a> to add indexing capabilities to the ASP.NET MVC application and search capabilities to the Windows Phone application.</p>

<p>The application we will be building is called PackageTrack. It is a simple web application where a user can create, read, update, and delete packages they like and use. The web application will be capable of managing the package information, indexing that data with Algolia, and providing a simple REST API for the data. We will also create a Windows Phone application with an auto suggest search box hooked into the Algolia search service to provide search results. Users will then be able to select one of the search results and have that information shown by requesting the data from the web application API.</p>

<h2>Prerequisites</h2>

<p>In order to follow along well, it will be helpful to share versions of tooling, operating system, and technology used for the tutorial. You will need to use (at the very least) Visual Studio 2013 with update 4. Also, in order to develop Windows Phone 8.1 applications, you will need to be developing on Windows 8 or greater. Finally, the application is being built using .NET framework 4.5.</p>

<h2>Create a new ASP.NET Web Application</h2>

<p>With Visual Studio running, create a new solution and choose an ASP.NET Web Application for your initial project. If you want to follow along exactly, name your solution <code>PackageTrack</code> and your project <code>PackageTrack.Web</code>.</p>

<p><img src="/images/algolia_csharp_01.png" alt="Screenshot 01" /></p>

<p>To keep this tutorial simple, change the authentication to <code>No Authentication</code>.</p>

<p><img src="/images/algolia_csharp_02.png" alt="Screenshot 02" /></p>

<p>You will also want to make sure MVC and Web API are selected.</p>

<p><img src="/images/algolia_csharp_03.png" alt="Screenshot 03" /></p>

<h2>Install necessary NuGet packages</h2>

<p>This application requires two new packages in order to work.</p>

<p><strong>Entity Framework</strong></p>

<p>Install the Entity Framework package. The version used in this tutorial is 6.1.3.</p>

<p><code>tcsh
PM&gt; Install-Package EntityFramework
</code></p>

<p><strong>Algolia Search</strong></p>

<p>Install the Algolia Search package. The version used in this tutorial is 3.0.5.</p>

<p><code>tcsh
PM&gt; Install-Package Algolia.Search
</code></p>

<p>Finally, we need to update all installed packages to make sure we are using the latest libraries and scripts. You can do this by right clicking the web project in Solution Explore and choosing <code>Manage NuGet Packages...</code>.</p>

<h2>Cleanup</h2>

<p>Now that we have our packages installed and updated, we need to perform a little cleanup in our project.</p>

<p>First, let's delete the Home Controller, <code>HomeController.cs</code>, and the <code>Home</code> directory within <code>Views</code>. We are removing the controller and its views because we will be creating our own later.</p>

<h2>Update our layout</h2>

<p>Our layout needs a little updating to improve the look and feel a bit. Update <code>\Vieews\Shared\_Layout.cshtml</code> with the following.</p>

<p>```html
&lt;!DOCTYPE html>
<html>
<head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;Package Track&lt;/title&gt;
@Styles.Render("~/Content/css")
@Scripts.Render("~/bundles/modernizr")
</code></pre>

<p></head>
<body></p>

<pre><code>&lt;div class="navbar navbar-inverse navbar-fixed-top"&gt;
    &lt;div class="container"&gt;
        &lt;div class="navbar-header"&gt;
            @Html.ActionLink("Package Track", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="container body-content"&gt;
    @RenderBody()
    &lt;hr /&gt;
    &lt;footer&gt;
        &lt;p&gt;&amp;copy; @DateTime.Now.Year - &lt;a href="https://www.algolia.com/" target="_blank"&gt;Algolia&lt;/a&gt;&lt;/p&gt;
    &lt;/footer&gt;
&lt;/div&gt;

@Scripts.Render("~/bundles/jquery")
@Scripts.Render("~/bundles/bootstrap")
@RenderSection("scripts", required: false)
</code></pre>

<p></body>
</html>
```</p>

<h2>Entity Framework and Database</h2>

<p>We are now ready to create our model and DbContext in order to take advantage of Entity Framework. What we will do is a create a simple model to represent our package that we want to store in the database. After that, we will create our DbContext which will allow us to easily add, remove, update, and more on our packages stored in the database.</p>

<p>By default, the project is setup to use a local MDF database. You are welcome to change it but for simplicity this tutorial will not.</p>

<p>To create our package model, create a new file named <code>Package.cs</code> inside the <code>Models</code> directory. Update the created class to look like the following.</p>

<p>```c#
public class Package
{</p>

<pre><code>public int Id { get; set; }
public string Name { get; set; }
public string Link { get; set; }
public int Count { get; set; }
</code></pre>

<p>}
```</p>

<p>Next, we need to create our DbContext. To do this, create a new directory called <code>Data</code> at the root of the project. Then create a new file named <code>PackageTrackContext.cs</code> inside this new directory. Update the code to the following.</p>

<p>```c#
using PackageTrack.Web.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Web;</p>

<p>namespace PackageTrack.Web.Data
{</p>

<pre><code>public class PackageTrackDbContext : DbContext
{
    public DbSet&lt;Package&gt; Packages { get; set; }
}
</code></pre>

<p>}
```</p>

<p>Before moving on, be sure to build your solution. This will be necessary for the next steps where we use Visual Studio tooling to scaffold our CRUD controller and views for us.</p>

<h2>Package CRUD</h2>

<p>We now need to create the controller, actions, and views in order to create, read, update, and delete packages. To do this we will use Visual Studio tooling. This will make it super simple. The following 3 screenshots show what to do.</p>

<p>First, right click the <code>Controller</code> directory and choose <code>Add</code> followed by <code>Controller</code>.</p>

<p><img src="/images/algolia_csharp_04.png" alt="Screenshot 04" /></p>

<p>Next, choose <code>MVC 5 Controller with views, using Entity Framework</code>.</p>

<p><img src="/images/algolia_csharp_05.png" alt="Screenshot 05" /></p>

<p>Finally, be sure to choose the Package model we created for the <code>Model class</code>, the PackageTrackDbContext we created for the <code>Data context class</code>, check <code>Use async controller actions</code>, and set the <code>Controller name</code> to HomeController.</p>

<p><img src="/images/algolia_csharp_06.png" alt="Screenshot 06" /></p>

<p>Visual Studio should create a new HomeController along with a set of views. You can now build and run your project. You should be able to create, read, update, and delete packages. Go head and do this now and create a few packages. We will need them later.</p>

<h2>Build an Admin controller</h2>

<p>We now need to create an Admin controller that will provide us the ability to issue index, re-index, and delete commands to our Algolia index.</p>

<p>Inside the <code>Controllers</code> directory, create a file named <code>AdminController.cs</code>. Update it to contain the following code.</p>

<p>```c#
using Algolia.Search;
using PackageTrack.Web.Data;
using PackageTrack.Web.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Web;
using System.Web.Mvc;</p>

<p>namespace PackageTrack.Web.Controllers
{</p>

<pre><code>public class AdminController : Controller
{
    private PackageTrackDbContext db = new PackageTrackDbContext();

    public ActionResult Index()
    {
        return View();
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task&lt;ActionResult&gt; ReIndexData()
    {
        return View();
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task&lt;ActionResult&gt; IndexData()
    {
        return View();
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task&lt;ActionResult&gt; DeleteData()
    {
        return View();
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            db.Dispose();
        }
        base.Dispose(disposing);
    }
}
</code></pre>

<p>}
```</p>

<p>Inside the <code>Views</code> directory, create a new directory named <code>Admin</code>. Now that we have a new place for our admin views, create a new view there named <code>Index.cshml</code>. This is where we will setup our ability to issue index commands. Update the view with the following code.</p>

<p>```html</p>

<h2>Admin</h2>




<div>
    <hr />

    <div class="form-actions no-color">
        @using (Html.BeginForm("reindexdata", "admin"))
        {
            @Html.AntiForgeryToken()
            <input type="submit" value="Re-Index Data" class="btn btn-default" />
        }
        <br />
        @using (Html.BeginForm("indexdata", "admin"))
        {
            @Html.AntiForgeryToken()
            <input type="submit" value="Index Data" class="btn btn-default" />
        }
        <br />
        @using (Html.BeginForm("deletedata", "admin"))
        {
            @Html.AntiForgeryToken()
            <input type="submit" value="Delete Data" class="btn btn-default" />
        }
    </div>
</div>


<p>```</p>

<p>Now we need to create 3 views that can be used to show when our index commands have completed. Create the following views with their markup inside the <code>Views\Admin</code> directory.</p>

<p><strong>ReIndexData.cshtml</strong></p>

<p>```html</p>

<h2>Data Re-Indexed</h2>


<p>```</p>

<p><strong>IndexData.cshtml</strong></p>

<p>```html</p>

<h2>Data Indexed</h2>


<p>```</p>

<p><strong>DeleteData.cshtml</strong></p>

<p>```html</p>

<h2>Data Deleted</h2>


<p>```</p>

<h2>Algolia time</h2>

<p>Up to this point, we have been doing standard .NET development and nothing with Algolia (except adding the NuGet package). We are now ready to start.</p>

<p>Since our web application allows our users to create, update, and delete packages, we need to be able to do the same things to our Algolia index. On top of that, there are cases where we need to perform an index on all of our data, do a full re-index where data is removed and then added, and also remove all data from our index. We do all this from our web application rather than the Windows Phone application because it is much more secure to have our server talking to Algolia rather than each client. We don't want our credentials that allow changing index data to fall into a user's hand.</p>

<h3>Create reusable Algolia client</h3>

<p>The AlgoliaClient allows our application to easily interact with our Algolia index. In order to keep performance optimal, we don't want to create an instance of this client each time we need it. To address this, we will create one AlgoliaClient and store it in an Application Variable.</p>

<p>Let's go ahead and do this now.</p>

<p>Open up your <code>Global.asax.cs</code> file and update it as follows.</p>

<p>```c#
using Algolia.Search;
using PackageTrack.Web.Data;
using PackageTrack.Web.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Http;
using System.Web.Mvc;
using System.Web.Optimization;
using System.Web.Routing;</p>

<p>namespace PackageTrack.Web
{</p>

<pre><code>public class MvcApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        AreaRegistration.RegisterAllAreas();
        GlobalConfiguration.Configure(WebApiConfig.Register);
        FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
        RouteConfig.RegisterRoutes(RouteTable.Routes);
        BundleConfig.RegisterBundles(BundleTable.Bundles);

        // Create our Algolia client
        var algoliaClient = new AlgoliaClient("&lt;APPLICATION_ID&gt;", "&lt;ADMIN_API_KEY&gt;");

        // Create our index helper
        var indexHelper = new IndexHelper&lt;Package&gt;(algoliaClient, "packages", "Id");

        // Store our index helper in an application variable.
        // We don't want to create a new one each time
        // because it will impact performance.
        Application.Add("PackageIndexHelper", indexHelper);
    }
}
</code></pre>

<p>}
```</p>

<p>What we are doing here is first creating an AlgoliaClient using our application id and key. You will need to update these two values using your own credentials. You can either use the Admin key already created for you or create your own key and choose the permissions allowed.</p>

<p>Next, we create an IndexHelper and inject our AlgoliaClient into it along with the name of the index and the value of our Package model identifier that should be mapped to the Algolia index object Id. The reason we want to specify the identifier in our model is because the IndexHelper will automatically build and  map our model to the Algolia index object.</p>

<p>Finally, we add our IndexHlper to the application variable so we can use it elsewhere in our application.</p>

<p>One thing to note is the index we are using in Algolia is called <code>packages</code>. You can either create it ahead of time or it will be automatically created when you issue index commands.</p>

<h3>Update our Admin controller to work with Algolia</h3>

<p>Now that we have an Algolia IndexHelper to use, we need to update our Admin controller to talk to Algolia when someone issues an indexing command.</p>

<p>Update each of the 3 following actions inside <code>AdminController.cs</code>. Make sure and add a using statement for Algolia.Search.</p>

<p>```c#
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<ActionResult> ReIndexData()
{</p>

<pre><code>// Get the package index helper from Application variable
var packageIndexHelper = HttpContext.Application.Get("PackageIndexHelper") as IndexHelper&lt;Package&gt;;
await packageIndexHelper.OverwriteIndexAsync(db.Packages, 1000);

return View();
</code></pre>

<p>}</p>

<p>[HttpPost]
[ValidateAntiForgeryToken]
public async Task<ActionResult> IndexData()
{</p>

<pre><code>// Get the package index helper from Application variable
var packageIndexHelper = HttpContext.Application.Get("PackageIndexHelper") as IndexHelper&lt;Package&gt;;
await packageIndexHelper.SaveObjectsAsync(db.Packages, 1000);

return View();
</code></pre>

<p>}</p>

<p>[HttpPost]
[ValidateAntiForgeryToken]
public async Task<ActionResult> DeleteData()
{</p>

<pre><code>// Get the package index helper from Application variable
var packageIndexHelper = HttpContext.Application.Get("PackageIndexHelper") as IndexHelper&lt;Package&gt;;
await packageIndexHelper.DeleteObjectsAsync(db.Packages, 1000);

return View();
</code></pre>

<p>}
```</p>

<p>The IndexHelper is very nice. It will automatically handle the steps needed to perform indexing, re-indexing, and deleting of data. The way it works is it already knows the identifier to look for in your model so when you make an OverwriteIndex, SaveObjects, or DeleteObjects call it automatically converts your model to JSON, adds an objectId field, sets the objectId field to the identifier you told it to use, and makes the necessary calls to Algolia.</p>

<p>Now is a great time to test things out. You should already have packages in your database that are not in your Algolia index. Try out the different functions under the <code>/admin</code> path. You should see your index get populated, re-populated, and cleared out depending on which function you use.</p>

<h3>Update our CRUD to work with Algolia</h3>

<p>Having administrative ability to manage our index is great, but we really need to have our index kept up to date as users create, update, and delete packages from our database.</p>

<p>We will do this by updating the actions inside our Home controller we created earlier to support our CRUD operations on packages.</p>

<p>Update each of the 3 following actions inside <code>HomeController.cs</code>. Make sure and add a using statement for Algolia.Search.</p>

<p>```c#
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<ActionResult> Create([Bind(Include = "Id,Name,Link,Count")] Package package)
{</p>

<pre><code>if (ModelState.IsValid)
{
    db.Packages.Add(package);
    await db.SaveChangesAsync();

    // Get the package index helper from Application variable
    var packageIndexHelper = HttpContext.Application.Get("PackageIndexHelper") as IndexHelper&lt;Package&gt;;
    await packageIndexHelper.SaveObjectAsync(package);

    return RedirectToAction("Index");
}

return View(package);
</code></pre>

<p>}</p>

<p>[HttpPost]
[ValidateAntiForgeryToken]
public async Task<ActionResult> Edit([Bind(Include = "Id,Name,Link,Count")] Package package)
{</p>

<pre><code>if (ModelState.IsValid)
{
    db.Entry(package).State = EntityState.Modified;
    await db.SaveChangesAsync();

    // Get the package index helper from Application variable
    var packageIndexHelper = HttpContext.Application.Get("PackageIndexHelper") as IndexHelper&lt;Package&gt;;
    await packageIndexHelper.SaveObjectAsync(package);

    return RedirectToAction("Index");
}
return View(package);
</code></pre>

<p>}</p>

<p>[HttpPost, ActionName("Delete")]
[ValidateAntiForgeryToken]
public async Task<ActionResult> DeleteConfirmed(int id)
{</p>

<pre><code>Package package = await db.Packages.FindAsync(id);
db.Packages.Remove(package);
await db.SaveChangesAsync();

// Get the package index helper from Application variable
var packageIndexHelper = HttpContext.Application.Get("PackageIndexHelper") as IndexHelper&lt;Package&gt;;
await packageIndexHelper.DeleteObjectAsync(package);

return RedirectToAction("Index");
</code></pre>

<p>}
```</p>

<p>What we did here was whenever a package is created, updated, or deleted, we use the IndexHelper to add, update, or remove the data within our index.</p>

<p>Go ahead and try it out.</p>

<h2>Implement real time search</h2>

<p>With all of our indexing in place, we are ready to add a real time search experience to our web application.</p>

<h3>Download JavaScript libraries</h3>

<p>We will need some JavaScript libraries in order to create the search feature. Download each of the following and save them in the <code>Scripts</code> directory with the names I indicate.</p>

<p><strong>typeahead.jquery.js</strong><br/>
<a href="https://cdn.jsdelivr.net/typeahead.js/0.10.5/typeahead.jquery.min.js">https://cdn.jsdelivr.net/typeahead.js/0.10.5/typeahead.jquery.min.js</a></p>

<p><strong>hogan.common.js</strong><br/>
<a href="https://cdn.jsdelivr.net/hogan.js/3.0.2/hogan.common.js">https://cdn.jsdelivr.net/hogan.js/3.0.2/hogan.common.js</a></p>

<p><strong>algoliasearch.min.js</strong><br/>
<a href="https://cdn.jsdelivr.net/algoliasearch/2.9/algoliasearch.min.js">https://cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js</a></p>

<h3>Bundle new JavaScript</h3>

<p>With the new scripts added to our project, we need to update our bundles to include them. Open up <code>\App_Start\BundleConfig.cs</code> and add the following new bundle.</p>

<p>```c#
bundles.Add(new ScriptBundle("~/bundles/main").Include(</p>

<pre><code>      "~/Scripts/typeahead.jquery.min.js",
      "~/Scripts/hogan.common.js",
      "~/Scripts/algoliasearch.min.js",
      "~/Scripts/main.js"));
</code></pre>

<p>```</p>

<h3>Update our layout</h3>

<p>Now we need to update our layout to include a search box and the new script bundle we created.</p>

<p>Open up <code>_Layout.cshtml</code> and modify the code as follows.</p>

<p>```html
....</p>

<div class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            @Html.ActionLink("Package Track", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
        </div>
        <div class="typeahead-container">
            <input id="typeahead-algolia" class="typeahead" type="text" placeholder="Search...">
        </div>
    </div>
</div>


<p>...</p>

<p>@Scripts.Render("~/bundles/jquery")
@Scripts.Render("~/bundles/bootstrap")
@Scripts.Render("~/bundles/main")
@RenderSection("scripts", required: false)
```</p>

<h3>Create JavaScript to tie UI with Algolia</h3>

<p>The following code needs to be added to a new file named <code>main.js</code> within the <code>Scripts</code> directory. This sets us up to perform searches with our packages index on Algolia. Be sure to update the application id and key using your search only key.</p>

<p>```javascript
$(document).ready(function () {</p>

<pre><code>var client = algoliasearch('&lt;APPLICATION ID&gt;', '&lt;SEARCH-ONLY API KEY&gt;');
var index = client.initIndex('&lt;INDEX NAME&gt;');

var template = Hogan.compile(
    '&lt;a href="http://scottksmith.com/home/details/}"&gt;' +
        '&lt;div class="hit"&gt;' +
            '&lt;div class="name"&gt;' +
                '} ' +
            '&lt;/div&gt;' +
            '' +
            '&lt;div class="attribute"&gt;: }&lt;/div&gt;' +
            '' +
        '&lt;/div&gt;' +
    '&lt;/a&gt;');

$('#typeahead-algolia').typeahead({
    highlight: false,
    hint: true,
    minLength: 1
},
{
    source: index.ttAdapter({ "hitsPerPage": 10 }),
    displayKey: 'Name',
    templates: {
        suggestion: function (hit) {
            // select matching attributes only
            hit.attributes = [];
            for (var attribute in hit._highlightResult) {
                if (attribute === 'Name') {
                    // already handled by the template
                    continue;
                }
                // all others attributes that are matching should be added in the attributes array
                // so we can display them in the dropdown menu. Non-matching attributes are skipped.
                if (hit._highlightResult[attribute].matchLevel !== 'none') {
                    hit.attributes.push({ attribute: attribute, value: hit._highlightResult[attribute].value });
                }
            }

            // render the hit using Hogan.js
            return template.render(hit);
        }
    }
});
</code></pre>

<p>});
```</p>

<h3>Style the search</h3>

<p>Finally, we want to style our search. Add the following CSS to <code>\Content\Site.css</code>.</p>

<p>```css
.typeahead-container {</p>

<pre><code>float: right;
</code></pre>

<p>}</p>

<p>.typeahead {</p>

<pre><code>padding: 0 5px;
margin-top: 10px;
width: 300px;
height: 30px;
font-size: 14px;
line-height: 30px;
max-width: none;
</code></pre>

<p>}</p>

<p>.tt-input,
.tt-hint {</p>

<pre><code>width: 396px;
height: 30px;
padding: 8px 12px;
font-size: 14px;
line-height: 30px;
border: 2px solid #ccc;
border-radius: 8px;
outline: none;
</code></pre>

<p>}</p>

<p>.tt-input {</p>

<pre><code>box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
</code></pre>

<p>}</p>

<p>.tt-hint {</p>

<pre><code>color: #999;
</code></pre>

<p>}</p>

<p>.tt-dropdown-menu {</p>

<pre><code>width: 422px;
margin-top: 12px;
padding: 8px 0;
background-color: #fff;
border: 1px solid #ccc;
border: 1px solid rgba(0, 0, 0, 0.2);
border-radius: 8px;
box-shadow: 0 5px 10px rgba(0,0,0,.2);
</code></pre>

<p>}</p>

<p>.tt-suggestion {</p>

<pre><code>padding: 3px 20px;
font-size: 14px;
line-height: 24px;
</code></pre>

<p>}</p>

<pre><code>.tt-suggestion.tt-cursor {
    color: #fff;
    background-color: #0097cf;
}

.tt-suggestion p {
    margin: 0;
}

.tt-suggestion em {
    font-weight: bold;
    font-style: normal;
}
</code></pre>

<p>.name {</p>

<pre><code>font-weight: bold;
</code></pre>

<p>}</p>

<p>.attribute {</p>

<pre><code>margin-left: 10px;
</code></pre>

<p>}
```</p>

<p>If you would like to get a more in depth tutorial on the real time search piece we just added, you can read other articles I wrote here.</p>

<p><a href="http://scottksmith.com/blog/2014/10/21/getting-started-with-algolia-real-time-search/">http://scottksmith.com/blog/2014/10/21/getting-started-with-algolia-real-time-search/</a></p>

<p><a href="http://scottksmith.com/blog/2014/10/29/algolia-real-time-search-with-twitters-typeaheadjs/">http://scottksmith.com/blog/2014/10/29/algolia-real-time-search-with-twitters-typeaheadjs/</a></p>

<h2>Create REST API for packages</h2>

<p>The last thing we need to do in our web application is to build a REST based API for our package information. This will be used by our Windows Phone application.</p>

<p>First, create a new directory within the <code>Controllers</code> directory and name it <code>Api</code>.</p>

<p>Right click on the Api folder and choose <code>Add</code> followed by <code>Controller</code>. Follow the next few screenshots to see what settings to use and values to set.</p>

<p><img src="/images/algolia_csharp_07.png" alt="Screenshot 07" /></p>

<p><img src="/images/algolia_csharp_08.png" alt="Screenshot 08" /></p>

<p><img src="/images/algolia_csharp_09.png" alt="Screenshot 09" /></p>

<p>Because we want to only return JSON even when the request header is not <code>application/json</code> we need to update our <code>WebApiConfig.cs</code> file in the <code>App_Start</code> directory.</p>

<p>```c#
using System.Net.Http.Headers;</p>

<p>  ...</p>

<p>  config.Formatters.JsonFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue("text/html"));
```</p>

<p>We are now ready to create our Windows Phone application that will perform searches using Algolia and show data from our web application.</p>

<h2>Create a new Windows Phone Application</h2>

<p>In our current solution, create a new project and choose <code>Blank App (Windows Phone)</code>. You can name it whatever you like, but I went with PackageTrack.Phone.</p>

<p><img src="/images/algolia_csharp_10.png" alt="Screenshot 10" /></p>

<h2>Install necessary NuGet package</h2>

<p>This application requires one new package in order to work.</p>

<p><strong>Algolia Search</strong></p>

<p>Install the Algolia Search package. The version used in this tutorial is 3.0.5.</p>

<p><code>tcsh
PM&gt; Install-Package Algolia.Search
</code></p>

<h2>Configure startup projects</h2>

<p>In order for both applications to work, we need to configure our solution to start the web and phone application when we build and run. The following screenshots show how to do this.</p>

<p><img src="/images/algolia_csharp_11.png" alt="Screenshot 11" /></p>

<p><img src="/images/algolia_csharp_12.png" alt="Screenshot 12" /></p>

<p>Debug or run your applications now to make sure both projects start.</p>

<h2>Build our application UI</h2>

<p>Now that our project and solution are ready to go, we can add some components to our application to build out our UI.</p>

<p>If <code>MainPage.xaml</code> is not open, you will want to open it now. This will load the designer view. The next two steps and screenshots show the two components we want to add to our view. Just drag each of the components from the Toolbox within Visual Studio into your UI as shown below.</p>

<h3>Add AutoSuggestBox</h3>

<p><img src="/images/algolia_csharp_13.png" alt="Screenshot 13" /></p>

<h3>Add WebView</h3>

<p><img src="/images/algolia_csharp_14.png" alt="Screenshot 14" /></p>

<p><img src="/images/algolia_csharp_15.png" alt="Screenshot 15" /></p>

<h3>Configure WebView</h3>

<p>We need to give our WebView a name so we can reference it within our code. You will need to name it <code>SearchWebView</code>. The following code shows the updated XAML for this change.</p>

<p><code>xml
&lt;WebView Name="SearchWebView" HorizontalAlignment="Left" Height="576" Margin="10,54,0,0" VerticalAlignment="Top" Width="380"/&gt;
</code></p>

<h3>Configure AutoSuggestBox events</h3>

<p>Our AutoSuggestBox is where the user will start typing a search query and will be responsible for searching our index on Algolia. We need to setup two events to handle when the text changes and when a suggestion is selected.</p>

<p>Update the MainPage XAML to the following for the AutoSuggestBox.</p>

<p><code>xml
&lt;AutoSuggestBox HorizontalAlignment="Left" Margin="10,10,0,0" VerticalAlignment="Top" Width="380" TextChanged="AutoSuggestBox_TextChanged" SuggestionChosen="AutoSuggestBox_SuggestionChosen"/&gt;
</code></p>

<p>When adding new event handlers in this fashion, the code behind is automatically created in <code>MainPage.xaml.cs</code>. If they are not there, be sure to add them as follows.</p>

<p>```c#
private void AutoSuggestBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
{</p>

<p>}</p>

<p>private void AutoSuggestBox_SuggestionChosen(AutoSuggestBox sender, AutoSuggestBoxSuggestionChosenEventArgs args)
{</p>

<p>}
```</p>

<h2>Add Algolia to our application</h2>

<p>If you don't have <code>MainPage.xaml.cs</code> open, open it now.</p>

<p>We are going to add the necessary code to add Algolia search capabilities to our application.</p>

<p>The first thing we need is to add two private members to our MainPage class. These will be an AlgoliaClient and Index.</p>

<p><code>c#
private AlgoliaClient algoliaClient = null;
private Index algoliaIndex = null;
</code></p>

<p>Next, we need to instantiate these objects within the constructor. Be sure to change the application id and search only key to the ones you used in the web project.</p>

<p>```c#
public MainPage()
{</p>

<pre><code>this.InitializeComponent();

this.NavigationCacheMode = NavigationCacheMode.Required;

algoliaClient = new AlgoliaClient("&lt;APPLICATION_ID&gt;", "&lt;SEARCH_ONLY_API_KEY&gt;");
algoliaIndex = algoliaClient.InitIndex("packages");
</code></pre>

<p>}
```</p>

<p>Finally, be sure to add the necessary using statement.</p>

<p><code>c#
using Algolia.Search;
</code></p>

<h2>Tie it all together</h2>

<p>We now need to create a class that can be used to deserialize the Algolia search responses. Inside <code>MainPage.xaml.cs</code> create the following class. You will notice it defines Name, Link, Count, and objectID. The first 3 are fields we defined in our web application. The last one is the ID that Algolia uses in its indexed data. This is the field we mapped our models ID field to.</p>

<p>Also, you will see we are overriding <code>ToString()</code>. This is because we will be adding each <code>Hit</code> object to our AutoSuggestBox and want to control how the data is shown.</p>

<p>```c#
private class PackagesResult
{</p>

<pre><code>public class Hit
{
    public string Name { get; set; }
    public string Link { get; set; }
    public string Count { get; set; }
    public string objectID { get; set; }

    public override string ToString()
    {
        return Name + Environment.NewLine +
            "  Link:\t" + Link + Environment.NewLine +
            "  Count:\t" + Count;
    }
}

public List&lt;Hit&gt; hits { get; set; }
</code></pre>

<p>}
```</p>

<p>Next we need to implement our search code each time a user enters a character in our AutoSuggestBox. Update the AutoSuggestBox event handler for TextChanged as follows.</p>

<p>```c#
private void AutoSuggestBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
{</p>

<pre><code>if (args.Reason == AutoSuggestionBoxTextChangeReason.UserInput)
{
    var searchTerm = sender.Text;
    var query = new Query(searchTerm);
    var result = algoliaIndex.SearchAsync(query).Result;
    var packagesResult = result.ToObject&lt;PackagesResult&gt;();

    sender.ItemsSource = packagesResult.hits;
}
</code></pre>

<p>}
```</p>

<p>What we are doing here is creating a new Algolia Query using the entered text. We then issue a search, get back the results as JSON, and convert it to a PackagesResult object. The last thing we do is add the list of Hits as the ItemsSource of our AutoSuggestBox. This will automatically show the results to the user.</p>

<p>Finally, we need to update the SuggestionChosen event for our AutoSuggestBox when a user selects one of the results we showed them. Update it as follows.</p>

<p>```c#
private void AutoSuggestBox_SuggestionChosen(AutoSuggestBox sender, AutoSuggestBoxSuggestionChosenEventArgs args)
{</p>

<pre><code>var hit = (PackagesResult.Hit)args.SelectedItem;
SearchWebView.Navigate(new Uri("http://localhost:8671/api/packages/" + hit.objectID));
</code></pre>

<p>}
```</p>

<p>All we are doing here is taking the selected item, reference that items object ID, and then navigating our WebView to that page. The page we are showing is the API endpoint we created in our web application. This is just a simple example of how to tie the two applications together. A more robust approach would be to process the data from the API and build a UI capable of viewing, editing, and deleting the data.</p>

<p><img src="/images/algolia_csharp_16.png" alt="Screenshot 16" /></p>

<h3>Wrap up</h3>

<p>That wraps up this tutorial on adding Algolia to an ASP.NET MVC application along with a Windows Phone 8.1 application. There was a lot going on here, but if you take out the standard stuff for our web and phone application, the Algolia part is very simple and straightforward.</p>

<p>If you found this article or others useful be sure to <a href="http://scottksmith.com/atom.xml">subscribe to my RSS feed</a> or <a href="https://twitter.com/scottksmith95">follow me on Twitter</a>. Also, if there are certain topics you would like me to write on, feel free to leave comments and let me know.</p>

<p>Source code for tutorial can be found <a href="https://github.com/algolia/tutorials/tree/master/csharp/src/PackageTrack">here on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Twitatron: Building a production web app with Node - Views &amp; Controllers]]></title>
    <link href="http://scottksmith.com/blog/2015/03/23/twitatron-building-a-production-web-app-with-node-views-and-controllers/"/>
    <updated>2015-03-23T14:59:00-07:00</updated>
    <id>http://scottksmith.com/blog/2015/03/23/twitatron-building-a-production-web-app-with-node-views-and-controllers</id>
    <content type="html"><![CDATA[<p>Welcome to part 2 of the Twitaron series</p>

<ol>
<li><a href="/blog/2014/10/05/twitatron-building-a-production-web-app-with-node/">Getting started</a></li>
<li><a href="/blog/2015/03/23/twitatron-building-a-production-web-app-with-node-views-and-controllers/">Views &amp; Controllers</a></li>
<li><a href="/blog/2015/05/26/twitatron-building-a-production-web-app-with-node-user-accounts/">User Accounts</a></li>
<li>Under development...</li>
</ol>


<p>In our <a href="/blog/2014/10/05/twitatron-building-a-production-web-app-with-node/">previous article</a> we started with the basics and built a web application capable of serving static content, compressing that content, and implementing cache headers.</p>

<p>In this installment of the Twitatron series, we will be diving into Views and Controllers.</p>

<h3>Getting setup</h3>

<p>Our view engine of choice will be <a href="http://jade-lang.com/reference/">Jade</a>. Jade is a terse language for writing HTML templates. It is capable of producing HTML, supports dynamic code, and supports reusability. You can find a <a href="http://jade-lang.com/tutorial/">tutorial here</a> to learn more about Jade.</p>

<p>First thing we need to do is create a directory to store our views. If you don't already have a directory named <code>views</code> you will need to create one now.</p>

<p>We will now need to tell Express about the view engine we wish to use.</p>

<p>Open up <code>server.js</code> and update it with the following code after the static middleware code.</p>

<p>```javascript
...</p>

<p>// Add static middleware
var oneDay = 86400000;
app.use(express.static(__dirname + '/public', { maxAge: oneDay }));</p>

<p>// Add jade view engine
app.set('views', __dirname + '/views');
app.set('view engine', 'jade');</p>

<p>// Create our Express router
var router = express.Router();</p>

<p>...
```</p>

<p>Next, we need to install the <a href="https://www.npmjs.org/package/jade">Jade</a> npm package.</p>

<p><code>tcsh
npm install jade --save
</code></p>

<p>What we did was add two pieces of middleware to our Express application. First, we told it to set the directory for our views to <code>/views</code>. Second, we told it to use Jade as our view engine.</p>

<p>We are now ready to create our first view.</p>

<h3>Our first view</h3>

<p>In the <code>views</code> directory create a new file named <code>home.jade</code> and add the following code to it.</p>

<p>```jade
doctype html
html
  head</p>

<pre><code>title Twitatron
</code></pre>

<p>  body</p>

<pre><code>h1 A Twitatron view has been born!
img(src="/img/birdatron-small.jpg")
</code></pre>

<p>```</p>

<p>Next, we need to create a route at the root of our application to render this view. Open up <code>server.js</code> and update it with the following code. Be sure to remove the "dummy" route we made in the first tutorial that just returned the text "Twitatron".</p>

<p>```javascript
...</p>

<p>// Create our Express router
var router = express.Router();</p>

<p>// Landing page route
router.get('/', function(req, res) {
  res.render('home');
});</p>

<p>// Register all our routes
app.use(router);</p>

<p>...
```</p>

<p>Finally, because we now have a view, we do not need the <code>index.html</code> file inside our <code>public</code> directory. Go ahead and delete it.</p>

<p>What we have done is setup a new route to handle GET requests to /. When a browser requests <code>http://localhost:3000/</code> it will execute the anonymous function we defined to render the view named <code>home</code>. Because we already defined the directory for our views to be <code>views</code>, Express will look for a view named <code>home.jade</code>, render it into html, and return it back to the requesting client.</p>

<p>Go ahead and test out your code to make sure everything is working. You should get back a response with the text "A Twitatron view has been born!" along with the Twitatron bird image.</p>

<h3>Layout and partials</h3>

<p>The next thing to update in our application is to implement a layout view and some partial views. This will help us reduce a significant amount of view code through reuse.</p>

<p>The first thing we will create is our layout view. This will define the general layout of our application and will be used in most of our other views. Inside the <code>views</code> directory, create a filed named <code>layout.jade</code>. Update it with the following code.</p>

<p>```jade
doctype html
html
  head</p>

<pre><code>title Twitatron
include partials/head
</code></pre>

<p>  body</p>

<pre><code>include partials/navigation
block content
include partials/footer
</code></pre>

<p>```</p>

<p>You will notice that our layout contains references to 3 partial views. Let's go ahead and create these now. First, create a sub-directory inside the <code>views</code> directory named <code>partials</code>. Next, create three new views named: <code>head.jade</code>, <code>navigation.jade</code>, and <code>footer.jade</code>. Update each one as follows.</p>

<p><strong>Head</strong></p>

<p><code>jade
meta(charset='utf-8')
meta(http-equiv='X-UA-Compatible', content='IE=edge')
meta(name='viewport', content='width=device-width, initial-scale=1.0')
meta(name='description', content='Automatically monitor your Twitter account for mentions.')
meta(name='keywords' content='twitter, mentions, api, rss, email, storage, bookmark')
meta(name='csrf-token', content=_csrf)
link(rel='apple-touch-icon', sizes='57x57', href='http://scottksmith.com/apple-touch-icon-57x57.png')
link(rel='apple-touch-icon', sizes='114x114', href='http://scottksmith.com/apple-touch-icon-114x114.png')
link(rel='apple-touch-icon', sizes='72x72', href='http://scottksmith.com/apple-touch-icon-72x72.png')
link(rel='apple-touch-icon', sizes='144x144', href='http://scottksmith.com/apple-touch-icon-144x144.png')
link(rel='apple-touch-icon', sizes='60x60', href='http://scottksmith.com/apple-touch-icon-60x60.png')
link(rel='apple-touch-icon', sizes='120x120', href='http://scottksmith.com/apple-touch-icon-120x120.png')
link(rel='apple-touch-icon', sizes='76x76', href='http://scottksmith.com/apple-touch-icon-76x76.png')
link(rel='apple-touch-icon', sizes='152x152', href='http://scottksmith.com/apple-touch-icon-152x152.png')
link(rel='icon' type='image/png', href='http://scottksmith.com/favicon-196x196.png', sizes='196x196')
link(rel='icon' type='image/png', href='http://scottksmith.com/favicon-160x160.png', sizes='160x160')
link(rel='icon' type='image/png', href='http://scottksmith.com/favicon-96x96.png', sizes='96x96')
link(rel='icon' type='image/png', href='http://scottksmith.com/favicon-16x16.png', sizes='16x16')
link(rel='icon' type='image/png', href='http://scottksmith.com/favicon-32x32.png', sizes='32x32')
meta(name='msapplication-TileColor' content='#9f00a7')
meta(name='msapplication-TileImage' content='/mstile-144x144.png')
</code></p>

<p>This view contains all our information for the head section of our HTML. Right now there are references to many icons for our application that do not yet exist. Don't worry about that for now as we will be making these in future tutorials.</p>

<p><strong>Navigation</strong></p>

<p>```jade
header
  div</p>

<pre><code>a(href='/') Twitatron
</code></pre>

<p>```</p>

<p>Pretty simple navigation piece for now. This will become more robust as we progress through the series.</p>

<p><strong>Footer</strong></p>

<p>```jade
footer
  div</p>

<pre><code>small &amp;copy; Twitatron 2015 
small Created by 
  a(href="http://scottksmith.com", target="_blank") Scott Smith
</code></pre>

<p>```</p>

<p>The last thing we need to do is update our current view for the homepage to use the new layout view. Update <code>home.jade</code> with the following.</p>

<p>```jade
extends layout</p>

<p>block content
  h1 A Twitatron view has been born!
  img(src="/img/birdatron-small.jpg")
```</p>

<p>Our view now says to extend our layout view and use the content defined within the content block within the block content section in the layout.</p>

<p>Now, all future views we create can extend the layout view and thus provide a head section, navigation, and footer. Later we will update our layout to add things like CSS, JavaScript, and more.</p>

<h3>Adding some dynamic code</h3>

<p>By themselves, views are helpful but they are much more powerful when you support dynamic code. This can be done easily taking advantage of Express. Let's go ahead and add a new element to our view that shows the IP address of the person making the request to our page.</p>

<p>Open up <code>server.js</code> and update our route handler as follows.</p>

<p>```javascript
...</p>

<p>// Landing page route
router.get('/', function(req, res) {
  res.locals.ip = req.ip;
  res.render('home');
});</p>

<p>...
```</p>

<p>What this does is add the IP address of the client making the request to the <code>res.locals.ip</code> object which makes it available to our views. The <code>res.locals</code> object is where you can add anything you want available in views.</p>

<p>Next, update <code>home.jade</code> as follows with a new element.</p>

<p>```jade
extends layout</p>

<p>block content
  h1 A Twitatron view has been born!
  h2 You are visiting from #{ip}
  img(src="/img/birdatron-small.jpg")
```</p>

<p>This example is more to illustrate how to add dynamic code to your view from within your application. In future articles, we will dive more deeply into how to take advantage of this.</p>

<h3>Controllers</h3>

<p>The next thing we need to help make our application easier to understand and maintain are controllers. As our application grows, our route handlers will increase in quantity and complexity. We will do this by pulling out most functionality and placing them within separate modules.</p>

<p>Let's start by updating the current route handler for we have the the root of our application.</p>

<p>If you don't already have a directory named <code>controllers</code> you will need to create one now. Inside this folder, create a new file named <code>home.js</code> and update it with the following code.</p>

<p><code>javascript
exports.index = function(req, res) {
  res.locals.ip = req.ip;
  res.render('home');
};
</code></p>

<p>What we have done is put our route handler code into a separate home controller module. Now we just need to update <code>server.js</code> to import the module and use it. Update <code>server.js</code>with the following code.</p>

<p>```javascript
// Load required packages
var path = require('path');
var express = require('express');
var compression = require('compression');</p>

<p>// Load controllers
var homeController = require('./controllers/home');</p>

<p>...</p>

<p>// Landing page route
router.get('/', homeController.index);</p>

<p>...
```</p>

<p>It may not seem like much now, but this type of pattern will help our application as we add a lot more functionality.</p>

<h3>Using path to normalize paths</h3>

<p>In two places, we have referenced the local file system using the <code>__dirname</code> global and a directory. To make our code more robust, we will take advantage of the core Node module <code>path</code>. The <code>path</code> module provides the function <code>join</code> that will join all the arguments into a normalized path.</p>

<p>For example, the following code would result in the path <code>/Users/scott/Projects/twitatron/public</code></p>

<p><code>javascript
path.join(__dirname, 'public')
</code></p>

<p>Update the two places within <code>server.js</code> where we are using the <code>dirname</code> global to use the <code>path</code> module.</p>

<p>```javascript
//Old
app.use(express.static(__dirname + '/public', { maxAge: oneDay }));</p>

<p>//New
app.use(express.static(path.join(__dirname, 'public'), { maxAge: oneDay }));</p>

<p>//Old
app.set('views', __dirname + '/views');</p>

<p>//New
app.set('views', path.join(__dirname, 'views'));
```</p>

<h3>Wrap up</h3>

<p>While our application may not yet be pretty, we have a solid base to build and grow from. We have views, layouts, partials, controllers, and more. Stay tuned for more articles on this tutorial series on building production ready Node web applications.</p>

<p>If you found this article or others useful be sure to <a href="http://scottksmith.com/atom.xml">subscribe to my RSS feed</a> or <a href="https://twitter.com/scottksmith95">follow me on Twitter</a>. Also, if there are certain topics you would like me to write on, feel free to leave comments and let me know.</p>

<p>Source code for this part can be found <a href="https://github.com/scottksmith95/twitatron/tree/master/02">here on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algolia Real Time Search With Firebase]]></title>
    <link href="http://scottksmith.com/blog/2014/12/09/algolia-real-time-search-with-firebase/"/>
    <updated>2014-12-09T16:17:00-08:00</updated>
    <id>http://scottksmith.com/blog/2014/12/09/algolia-real-time-search-with-firebase</id>
    <content type="html"><![CDATA[<p>One key feature of <a href="https://www.firebase.com/">Firebase</a> is building realtime applications by using their backend to store and sync data. Algolia further enhances that by providing realtime search capabilities. In a few simple steps, this tutorial will teach you how to import your existing data, index new data as it is added to Firebase, and remove indexed data when it is removed from Firebase.</p>

<p>Algolia's <a href="https://github.com/algolia/algoliasearch-client-js">Node.js client</a> simplifies the integration of your Firebase applications with Algolia's real time search service. The module makes it easy for you to use Algolia's search capabilities in a manner that will be familiar to those already developing Firebase and Node.js applications.</p>

<h2>Prerequisites</h2>

<h3>Familiar with Firebase</h3>

<p>This tutorial assumes you are familiar with Firebase, how it works, and how to build Firebase applications. If you would like to learn more before continuing with this tutorial, I suggest reading the following documentation and tutorials:</p>

<ol>
<li><a href="https://www.firebase.com/how-it-works.html">Getting started</a></li>
<li><a href="https://www.firebase.com/docs/web/quickstart.html">Quickstart web tutorial</a></li>
<li><a href="https://www.firebase.com/docs/web/guide/">Web development guide</a></li>
</ol>


<h2>Create a Node.js Application</h2>

<p>In order to index your Firebase data and continually add/update index information, you will need to create a Node.js application. This application will be responsible for getting data out of Firebase and indexing it with Algolia. It can then be run anywhere like Heroku, Nodejitsu, AWS, Azure, etc.</p>

<p>In this tutorial, we will be indexing contact information in a Firebase application. Be sure to change 'YourApplicationID' and 'YourAPIKey' to your account values <a href="https://www.algolia.com/licensing">here</a>. Because we are making calls that require more than read access, you will need to create a new key or use an existing one that can Add Records, Delete Records, and Delete Index (for reindexing example). You will also need to set your Firebase 'INSTANCE' to the one your application uses.</p>

<p>Here is the intial portion of the Node.js application.</p>

<p>```javascript
var Firebase = require('firebase');
var algoliasearch = require('algoliasearch');
var client = algoliasearch('YourApplicationID', 'YourAPIKey');
var index = client.initIndex('contacts');</p>

<p>// Connect to our Firebase contacts data
var fb = new Firebase('<INSTANCE>.firebaseio.com/contacts');
```</p>

<p>Be sure to install the necessary packages so your application will run.</p>

<p><code>tcsh
npm install firebase --save
npm install algoliasearch --save
</code></p>

<h2>Import Existing Data</h2>

<p>In many cases, you may already have data within your Firebase application. In order to integrate with Algolia, you will want to index that data. We will use contact information being stored within Firebaseio as our example. Add the following code to your Node.js application.</p>

<p>```javascript
// Get all data from Firebase
fb.on('value', initIndex);</p>

<p>function initIndex(dataSnapshot) {
  // Array of data to index
  var objectsToIndex = [];</p>

<p>  // Get all objects
  var values = dataSnapshot.val();</p>

<p>  // Process each Firebase ojbect
  for (var key in values) {</p>

<pre><code>if (values.hasOwnProperty(key)) {
  // Get current Firebase object
  var firebaseObject = values[key];

  // Specify Algolia's objectID using the Firebase object key
  firebaseObject.objectID = key;

  // Add object for indexing
  objectsToIndex.push(firebaseObject);
}
</code></pre>

<p>  }</p>

<p>  // Add or update new objects
  index.saveObjects(objectsToIndex, function(err, content) {</p>

<pre><code>if (err) {
  throw err;
}

console.log('Firebase&lt;&gt;Algolia import done');
</code></pre>

<p>  });
}
```</p>

<p>To ensure the indexing performs well it is suggested you limit the number of items indexed per call between 1,000 and 10,000 depending on the object size.</p>

<p>Once you run this code, you will have all of your existing Firebase data indexed with Algolia. You will want to remove this code once is is done because the event will continue to fire each time data is added.</p>

<h2>Reindex Data</h2>

<p>Sometimes, you may have the need to completely reindex your data. This means removing data from the index that may not longer exist, adding new data, and updating existing data. The following code can be added to the Node.js application to perform a reindexing. You will want to remove or comment out the initial index code if currently present.</p>

<p>```javascript
// Get all data from Firebase
fb.on('value', reindexIndex);</p>

<p>function reindexIndex(dataSnapshot) {
  // Array of objects to index
  var objectsToIndex = [];</p>

<p>  // Create a temp index
  var tempIndexName = 'contacts_temp';
  var tempIndex = client.initIndex(tempIndexName);</p>

<p>  // Get all objects
  var values = dataSnapshot.val();</p>

<p>  // Process each Firebase object
  for (var key in values) {</p>

<pre><code>if (values.hasOwnProperty(key)) {
  // Get current Firebase object
  var firebaseObject = values[key];

  // Specify Algolia's objectID using the Firebase object key
  firebaseObject.objectID = key;

  // Add object for indexing
  objectsToIndex.push(firebaseObject);
}
</code></pre>

<p>  }</p>

<p>  // Add or update new objects
  index.saveObjects(objectsToIndex, function(err, content) {</p>

<pre><code>if (err) {
  throw err;
}

// Overwrite main index with temp index
client.moveIndex(tempIndexName, 'contacts', function(err, content) {
  if (err) {
    throw err;
  }

  console.log('Firebase&lt;&gt;Algolia reimport done');
});
</code></pre>

<p>  });
}
```</p>

<p>To ensure the reindexing performs well it is suggested you limit the number of items indexed per call between 1,000 and 10,000 depending on the object size.</p>

<p>Once you run this code, you will have all of your existing Firebase data reindexed with Algolia. You will want to remove this code once is is done because the event will continue to fire each time data is added.</p>

<h2>Add or Update Data</h2>

<p>Now, we need to handle the case where data is being added or updated. We can easily setup our code to automatically add or update data to our search index by attaching to the 'child_added' and 'child_changed' events. This will allow us to define code that will be called after data is stored in Firebase. Add the following code to your Node.js application.</p>

<p>```javascript
// Listen for changes to Firebase data
fb.on('child_added', addOrUpdateObject);
fb.on('child_changed', addOrUpdateObject);</p>

<p>function addOrUpdateObject(dataSnapshot) {
  // Get Firebase object
  var firebaseObject = dataSnapshot.val();</p>

<p>  // Specify Algolia's objectID using the Firebase object key
  firebaseObject.objectID = dataSnapshot.key();</p>

<p>  // Add or update object
  index.saveObject(firebaseObject, function(err, content) {</p>

<pre><code>if (err) {
  throw err;
}

console.log('Firebase&lt;&gt;Algolia object saved');
</code></pre>

<p>  });
}
```</p>

<p>Now, whenever contact data is saved in Firebase, it will automatically be indexed with Algolia.</p>

<h2>Delete Data</h2>

<p>Next, we need to handle the case where data is deleted from your Firebase application. In order to do this, we can attach to the 'child_removed' event. This will allow us to define code that will be called after data is removed from Firebase. Add the following code to your Node.js application.</p>

<p>```javascript
// Listen for changes to Firebase data
fb.on('child_removed', removeIndex);</p>

<p>function removeIndex(dataSnapshot) {
  // Get Algolia's objectID from the Firebase object key
  var objectID = dataSnapshot.key();</p>

<p>  // Remove the object from Algolia
  index.deleteObject(objectID, function(err, content) {</p>

<pre><code>if (err) {
  throw err;
}

console.log('Firebase&lt;&gt;Algolia object deleted');
</code></pre>

<p>  });
}
```</p>

<p>Now, whenever contact data is removed from Firebase, it will automatically get removed from Algolia.</p>

<h2>Next Steps</h2>

<ol>
<li><a href="https://www.algolia.com/doc/node">Read the Node.js documentation</a></li>
<li><a href="https://github.com/algolia/algoliasearch-client-node#commands-reference">Dive into the Node.js command reference</a></li>
<li><a href="https://github.com/algolia/algoliasearch-client-node">Explore the Node.js API client source code</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algolia Real Time Search With Parse]]></title>
    <link href="http://scottksmith.com/blog/2014/12/08/algolia-real-time-search-with-parse/"/>
    <updated>2014-12-08T08:42:00-08:00</updated>
    <id>http://scottksmith.com/blog/2014/12/08/algolia-real-time-search-with-parse</id>
    <content type="html"><![CDATA[<p>One key feature of <a href="https://parse.com/">Parse</a> is for applications to use Parse Core as their data store. In a few simple steps, this tutorial will teach you how to import your existing data, index new data as it is added to Parse, and remove indexed data when it is removed from Parse.</p>

<p>The <a href="https://github.com/algolia/algoliasearch-client-js#parsecom">Algolia Parse Module</a> simplifies the integration of your Parse based applications with Algolia's real time search service. The module makes it easy for you to use Algolia's search capabilities in a manner that will be familiar to those already using the Algolia Node.js client APIs.</p>

<h2>Prerequisites</h2>

<h3>Familiar with Parse</h3>

<p>This tutorial assumes you are familiar with Parse, how it works, and how to build Cloud Code applications. If you would like to learn more before continuing with this tutorial, I suggest reading the following documentation and tutorials:</p>

<ol>
<li><a href="https://parse.com/docs/cloud_code_guide#started">Getting started with Cloud Code</a></li>
<li><a href="https://parse.com/apps/quickstart#parse_data/web/new">Parse quickstart web project</a></li>
<li><a href="https://parse.com/apps/quickstart#cloud_code/unix">Parse quickstart Cloud Code project on Mac/Linux</a></li>
<li><a href="https://parse.com/apps/quickstart#cloud_code/windows">Parse quickstart Cloud Code project on Windows</a></li>
</ol>


<h2>Add Agolia Real Time Search to the Project</h2>

<p>In order to integrate Aloglia within your Parse application, you will need to add the Algolia Node.js client. Copy <a href="https://raw.githubusercontent.com/algolia/algoliasearch-client-js/master/dist/algoliasearch.parse.js">algoliasearch.parse.js</a> to <code>cloud/algoliasearch.parse.js</code> within your Parse Cloud Code directory.</p>

<h2>Import Existing Data</h2>

<p>In many cases, you may already have data within your Parse application. In order to integrate with Algolia, you will want to index that data. We will use contact information being stored within Parse as our example.</p>

<p>```javascript
var algoliasearch = require('cloud/algoliasearch.parse.js');
var client = algoliasearch('YourApplicationID', 'YourAPIKey');
var index = client.initIndex('contacts');</p>

<p>function indexData() {
  var objectsToIndex = [];</p>

<p>  //Create a new query for Contacts
  var query = new Parse.Query('Contact');</p>

<p>  // Find all items
  query.find({</p>

<pre><code>success: function(contacts) {
  // prepare objects to index from contacts
  objectsToIndex = contacts.map(function(contact) {
    // convert to regular key/value JavaScript object
    contact = contact.toJSON();

    // Specify Algolia's objectID with the Parse.Object unique ID
    contact.objectID = contact.objectId;

    return contact;
  });

  // Add or update new objects
  index.saveObjects(objectsToIndex, function(err, content) {
    if (err) {
      throw err;
    }

    console.log('Parse&lt;&gt;Algolia import done');
  });
},
error: function(err) {
  throw err;
}
</code></pre>

<p>  });
}
```</p>

<p>You can now use this function within your own Parse Cloud Code functions in order to index your existing data.</p>

<p>Be sure to change 'YourApplicationID' and 'YourAPIKey' to your account values <a href="https://www.algolia.com/licensing">here</a>. Because we are making calls that require more than read access, you will need to create a new key or use an existing one that can Add Records, Delete Records, and Delete Index (for reindexing example). If you create a new key, you will need to make sure it can Add Records and Delete Records.</p>

<h2>Reindex Data</h2>

<p>Sometimes, you may have the need to completely reindex your data. This means removing data from the index that may not longer exist, adding new data, and updating existing data. The following code can be used within your own Parse Cloud Code functions to perform a reindexing.</p>

<p>```javascript
var tempIndexName = 'contacts_temp';
var mainIndexName = 'contacts';
var algoliasearch = require('cloud/algoliasearch.parse.js');
var client = algoliasearch('YourApplicationID', 'YourAPIKey');
var tempIndex = client.initIndex(tempIndexName);</p>

<p>var reindexData = function() {
  var objectsToIndex = [];</p>

<p>  // Create a temp index
  var tempIndex = client.initIndex(tempIndexName);</p>

<p>  // Create a new query for Contacts
  var query = new Parse.Query('Contact');</p>

<p>  // Find all items
  query.find({</p>

<pre><code>success: function(contacts) {
  // prepare objects to index from contacts
  objectsToIndex = contacts.map(function(contact) {
    // convert to regular key/value JavaScript object
    contact = contact.toJSON();

    // Specify Algolia's objectID with the Parse.Object unique ID
    contact.objectID = contact.objectId;

    return contact;
  });

  // Add new objects to temp index
  tempIndex.saveObjects(objectsToIndex, function(err, content) {
    if (err) {
      throw err;
    }

    // Overwrite main index with temp index
    client.moveIndex(tempIndexName, mainIndexName, function(err, content) {
      if (err) {
        throw err;
      }

      console.log('Parse&lt;&gt;Algolia reimport done');
    });
  });
},
error: function(err) {
  throw err;
}
</code></pre>

<p>  });
};
```</p>

<h2>Add or Update Data</h2>

<p>Now, we need to handle the case where data is being added or updated. We can easily setup our code to automatically add or update data to our search index by using the <code>afterSave</code> Parse function. This will allow us to define code that will be called after data is stored in Parse.</p>

<p>```javascript
var algoliasearch = require('cloud/algoliasearch.parse.js');
var client = algoliasearch('YourApplicationID', 'YourAPIKey');
var index = client.initIndex('contacts');</p>

<p>Parse.Cloud.afterSave('Contact', function(request) {
  // Convert Parse.Object to JSON
  var objectToSave = request.object.toJSON();</p>

<p>  // Specify Algolia's objectID with the Parse.Object unique ID
  objectToSave.objectID = objectToSave.objectId;</p>

<p>  // Add or update object
  index.saveObject(objectToSave, function(err, content) {</p>

<pre><code>if (err) {
  throw err;
}

console.log('Parse&lt;&gt;Algolia object saved');
</code></pre>

<p>  });
});
```</p>

<p>Now, whenever contact data is saved in Parse, it will automatically be indexed with Algolia.</p>

<h2>Delete Data</h2>

<p>Next, we need to handle the case where data is deleted from your Parse application. In order to do this, we can use the <code>afterDelete</code> Parse function. This will allow us to define code that will be called after data is removed from Parse.</p>

<p>```javascript
var algoliasearch = require('cloud/algoliasearch.parse.js');
var client = algoliasearch('YourApplicationID', 'YourAPIKey');
var index = client.initIndex('contacts');</p>

<p>Parse.Cloud.afterDelete('Contact', function(request) {
  // Get Algolia objectID
  var objectID = request.object.id;</p>

<p>  // Remove the object from Algolia
  index.deleteObject(objectID, function(err, content) {</p>

<pre><code>if (err) {
  throw err;
}

console.log('Parse&lt;&gt;Algolia object deleted');
</code></pre>

<p>  });
});
```</p>

<p>Now, whenever contact data is removed from Parse, it will automatically get removed from Algolia.</p>

<h2>Next Steps</h2>

<ol>
<li><a href="https://www.algolia.com/doc/node">Read the Node.js documentation</a></li>
<li><a href="https://github.com/algolia/algoliasearch-client-node#commands-reference">Dive into the Node.js command reference</a></li>
<li><a href="https://github.com/algolia/algoliasearch-client-node">Explore the Node.js API client source code</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
